<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>BetweenKit by ice3-software</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>BetweenKit</h1>
        <p>A robust drag-and-drop framework for iOS. </p>

        <p class="view"><a href="https://github.com/ice3-software/between-kit">View the Project on GitHub <small>ice3-software/between-kit</small></a></p>


        <ul>
          <li><a href="https://github.com/ice3-software/between-kit/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/ice3-software/between-kit/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/ice3-software/between-kit">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h1>

<h3>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h3>

<p>This document describes how you can use <code>BetweenKit</code> in your application. It introduces the concepts of the domain and then explores the core framework components. It provides example code snippets where possible but for full working examples, see the various <a href="">use cases</a> and <a href="">unit tests</a>.</p>

<h3>
<a id="problem-domain" class="anchor" href="#problem-domain" aria-hidden="true"><span class="octicon octicon-link"></span></a>Problem Domain</h3>

<p>It isn't particularly easy to build smooth drag-and-drop into your iOS applications, especially when you are dealing with multiple data-view components such as tables and collections. To achieve drag-and-drop in the past I've found myself building complex view controllers that deal with all manner of things including gesture handling, geometric conversion, data manipulation and rendering. The view controllers quickly became difficult to maintain and the unsegregated nature of the drag-and-drop functionality meant that reusing and extending it was nearly impossible.</p>

<h3>
<a id="premises" class="anchor" href="#premises" aria-hidden="true"><span class="octicon octicon-link"></span></a>Premises</h3>

<p><code>BetweenKit</code> aims to abstracting away the various <code>UIKit</code> interactions required to implement drag-and-drop, and expose a clean API. It relies on a series of premises about drag-and-drop from which we can model the domain:</p>

<ul>
<li>A <strong>collection</strong> is a view that contains and array of child <strong>items</strong>.</li>
<li>A <strong>drag arena</strong> consists of a <strong>superview</strong> and an ordered set of <strong>collections</strong> that exist as subviews within that superview.</li>
<li>The order of the collections in the drag arena determines their drag / drop priority. That is, if a collection sits at the beginning of the drag arena's ordered set of collections, then drags and drops occurring on that collection will be recognized in place of any of the later collections in the set.</li>
<li>A drag <strong>starts</strong> if and only if a gesture is started within the bounds of a <strong>draggable</strong> item of a collection in the drag arena.</li>
<li>
<strong>Dragging</strong> occurs if and only if, immediately after a drag has been started, the location of the gesture changes within the drag arena.</li>
<li>A drag <strong>stops</strong> if and only if immediately after dragging the gesture stops, is cancelled or finishes.</li>
<li>A <strong>deletion</strong> occurs if and only if the drag stops at a point which is specified as being <strong>deletable</strong>. For example, the user may designate certain bounds within the drag arena to be 'delete on drop' areas.</li>
<li>A <strong>rearrange</strong> occurs if and only if the drag stops within the bounds of the collection that it started in, on a different item in that collection which is specified as being <strong>rearrangeable</strong>, and on a point in the drag arena that is not specified as being deletable.</li>
<li>A <strong>drop</strong> occurs if and only if the drag stops within the bounds of another collection in the drag arena, on a specific item or point that is specified as <strong>droppable</strong> within that collection, and on a point in the drag arena which is not specified as being deletable.</li>
</ul>

<h3>
<a id="collections" class="anchor" href="#collections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Collections</h3>

<p>Classes that conform to the <code>I3Collection</code> protocol are our <strong>collections</strong> and should be subclasses of <code>UIView</code>. Implementations of <code>I3Collection</code> should use <code>NSIndexPath</code>s to access their child items for obvious conventional reasons.</p>

<p>The framework comes bundled with some convenient implementations of this protocol in the form of class categories for <code>UITableView</code> and <code>UICollectionView</code>, but there's no reason why you can't implement your own if required. This is a good example of the framework's loose coupling - its dependent on an abstractions not on concrete types.</p>

<h3>
<a id="drag-arena" class="anchor" href="#drag-arena" aria-hidden="true"><span class="octicon octicon-link"></span></a>Drag Arena</h3>

<p><code>I3DragArena</code> is our <strong>drag arena</strong>. Its only hard dependency is a <code>superview</code>, which should be injected via its constructor. You can register collections in the drag arena by adding them to its <code>collections</code> property, which is an <code>NSMutableOrderedSet</code>.</p>

<p>Note that it is your responsibillity to make sure the following preconditions to using the <code>I3DragArena</code> are met:</p>

<ul>
<li>That the <code>superview</code> is not <code>nil</code>
</li>
<li>That in the <code>superview</code> is above any view added to the <code>collections</code> set in the view heirarchy</li>
<li>That any instance added to the <code>collections</code> set is of the type <code>UIView&lt;I3Collection&gt;</code>
</li>
</ul>

<p>The following snippet demonstrates building a <code>I3DragArena</code> using the provided <code>UITableView</code> collection category:</p>

<div class="highlight highlight-Objective-C"><pre>
#<span class="pl-k">import</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>BetweenKit/UITableView+I3Collection.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">import</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>BetweenKit/I3DragArea.h<span class="pl-pds">&gt;</span></span>

...

<span class="pl-c">/// Dependencies are pulled form somewhere</span>

UIView *superview = ...
UITableView *table1 = ...
UITableView *table2 = ...

<span class="pl-c">/// Create a drag arena</span>

I3DragArena *arena = [[I3DragArena <span class="pl-s3">alloc</span>] <span class="pl-s3">initWithSuperview:</span>superview <span class="pl-s3">containingCollections:</span>@[table1, table2]];

<span class="pl-c">/// You can manipulate the registered ordered set of collections</span>

UITableView *table3 = ...
UITableView *table4 = ...

[arena.collections <span class="pl-s3">addObject:</span>table3];
[arena.collections <span class="pl-s3">insertObject:</span>table4 <span class="pl-s3">atIndex:</span><span class="pl-c1">1</span>];
[arena.collections <span class="pl-s3">removeObjectAtIndex:</span><span class="pl-c1">0</span>];

</pre></div>

<h3>
<a id="gesture-coordinator" class="anchor" href="#gesture-coordinator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gesture Coordinator</h3>

<p>The next component is responsible for listening for and coordinating gestures in order to recognize the different drag/drop events: drag <strong>starting</strong>, <strong>dragging</strong>, drag <strong>stopping</strong>, <strong>deletion</strong>, <strong>rearranging</strong> and <strong>dropping</strong>... the <code>I3GestureCoordinator</code>.</p>

<p>It has a couple of hard dependencies: </p>

<ul>
<li>The <code>I3DragArena</code>, which should be injected via the constructor</li>
<li>A <code>UIGestureRecongizer</code> configured to listen to the arena's superview, which can either be injected via the constructor or will be created 'behind the scenes' as a <code>UIPanGestureRecongizer</code> if <code>nil</code> is passed to the constructor</li>
</ul>

<p>and a couple of soft dependencies:</p>

<ul>
<li>An object implementing the <code>I3DragDataSource</code> protocol</li>
<li>An object implementing the <code>I3DragRenderDelegate</code> protocol</li>
</ul>

<h3>
<a id="data-source" class="anchor" href="#data-source" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Source</h3>

<p>Classes that conform to <code>I3DragDataSource</code> act as our data sources. This (again, for obvious conventional reasons) closely resembles the data source pattern used by <code>UITableView</code>s and <code>UICollectionView</code>s. </p>

<p>Our data source is responsible for managing all the data associated with items in the environment's collections. It exposes a set of assertion methods, which are used by the coordinator to determine whether a particular item or point has a particular property. For example the result of:</p>

<div class="highlight highlight-Objective-C"><pre>-(<span class="pl-st">BOOL</span>) canItemBeDraggedAt:(<span class="pl-s3">NSIndexPath</span> *)at inCollection:(UIView&lt;I3Collection&gt; *)collection;</pre></div>

<p>is used by the coordinator to determine whether a drag can start on particular item at a given index path in a given collection. Typically the implementation of assertion methods do not mutate the state of the data source, that is they should normally provide an interface by which the gesture coordinator can query about <em>how</em> the collections should be handled without having to worry about any side affects.</p>

<p>Our data source also implements some methods for mutating the data, for example:</p>

<div class="highlight highlight-Objective-C"><pre>-(<span class="pl-st">void</span>) dropItemAt:(<span class="pl-s3">NSIndexPath</span> *)from fromCollection:(UIView&lt;I3Collection&gt; *)fromCollection toItemAt:(<span class="pl-s3">NSIndexPath</span> *)to onCollection:(UIView&lt;I3Collection&gt; *)toCollection;</pre></div>

<p>should be implemented to update the data in the event that an item at <code>from</code> is dropped from the <code>fromCollection</code> to the item at <code>to</code> in the <code>toCollection</code>. These methods are called by the gesture coordinator whenever the relevant drag/drop event occurs.</p>

<p>This snippet demonstrates a very basic <code>I3DragDataSource</code> implementation that supports <strong>dropping</strong> and <strong>rearranging</strong>:</p>

<div class="highlight highlight-Objective-C"><pre>
#<span class="pl-k">import</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>BetweenKit/I3DragDataSource.h<span class="pl-pds">&gt;</span></span>

...

@implementation

#<span class="pl-k">pragma mark</span> - I3DragDataSource assertions


-(<span class="pl-st">BOOL</span>) canItemBeDraggedAt:(<span class="pl-s3">NSIndexPath</span> *)at inCollection:(UIView&lt;I3Collection&gt; *)collection{
    <span class="pl-k">return</span> <span class="pl-c1">YES</span>;
}


-(<span class="pl-st">BOOL</span>) canItemFrom:(<span class="pl-s3">NSIndexPath</span> *)from beRearrangedWithItemAt:(<span class="pl-s3">NSIndexPath</span> *)to inCollection:(UIView&lt;I3Collection&gt; *)collection{
    <span class="pl-k">return</span> <span class="pl-c1">YES</span>;
}


-(<span class="pl-st">BOOL</span>) canItemAt:(<span class="pl-s3">NSIndexPath</span> *)from fromCollection:(UIView&lt;I3Collection&gt; *)fromCollection beDroppedAtPoint:(CGPoint) at onCollection:(UIView&lt;I3Collection&gt; *)toCollection{
    <span class="pl-k">return</span> <span class="pl-c1">YES</span>;
}


#<span class="pl-k">pragma mark</span> - I3DragDataSource update methods


-(<span class="pl-s3">NSMutableArray</span> *)dataForCollection:(UIView *)collection{
    <span class="pl-k">return</span> collection == self.<span class="pl-vo">leftTable</span> ? self.<span class="pl-vo">leftData</span> : self.<span class="pl-vo">rightData</span>;
}


-(<span class="pl-st">void</span>) rearrangeItemAt:(<span class="pl-s3">NSIndexPath</span> *)from withItemAt:(<span class="pl-s3">NSIndexPath</span> *)to inCollection:(UIView&lt;I3Collection&gt; *)collection{

    UITableView *targetTableView = (UITableView *)collection;
    <span class="pl-s3">NSMutableArray</span> *targetDataset = [<span class="pl-v">self</span> <span class="pl-s3">dataSetForCollection:</span>collection]

    [targetDataset <span class="pl-s3">exchangeObjectAtIndex:</span>to.row <span class="pl-s3">withObjectAtIndex:</span>from.row];
    [targetTableView <span class="pl-s3">reloadRowsAtIndexPaths:</span>@[to, from] <span class="pl-s3">withRowAnimation:</span>UITableViewRowAnimationFade];
    [<span class="pl-v">self</span> <span class="pl-s3">logUpdatedData</span>];
}


-(<span class="pl-st">void</span>) dropItemAt:(<span class="pl-s3">NSIndexPath</span> *)fromIndex fromCollection:(UIView&lt;I3Collection&gt; *)fromCollection toItemAt:(<span class="pl-s3">NSIndexPath</span> *)toIndex onCollection:(UIView&lt;I3Collection&gt; *)toCollection{

    UITableView *fromTable = (UITableView *)fromCollection;
    UITableView *toTable = (UITableView *)toCollection;

    <span class="pl-s3">NSMutableArray</span> *fromDataset = [<span class="pl-v">self</span> <span class="pl-s3">dataForCollection:</span>fromTable];
    <span class="pl-s3">NSMutableArray</span> *toDataset = [<span class="pl-v">self</span> <span class="pl-s3">dataForCollection:</span>toTable];
    <span class="pl-s3">NSNumber</span> *dropDatum = [fromDataset <span class="pl-s3">objectAtIndex:</span>fromIndex.row];

    [fromDataset <span class="pl-s3">removeObjectAtIndex:</span>fromIndex.row];
    [toDataset <span class="pl-s3">insertObject:</span>dropDatum <span class="pl-s3">atIndex:</span>toIndex.row];

    [fromTable <span class="pl-s3">deleteRowsAtIndexPaths:</span>@[fromIndex] <span class="pl-s3">withRowAnimation:</span>UITableViewRowAnimationFade];
    [toTable <span class="pl-s3">insertRowsAtIndexPaths:</span>@[toIndex] <span class="pl-s3">withRowAnimation:</span>UITableViewRowAnimationFade];

}

@end
</pre></div>

<p>A common convention is to implement <code>I3DragDataSource</code> in your <code>UIViewController</code>.</p>

<p>All data source methods are optional apart from the 'drag start' assertion: </p>

<div class="highlight highlight-Objective-C"><pre>-(<span class="pl-st">BOOL</span>) canItemBeDraggedAt:(<span class="pl-s3">NSIndexPath</span> *)at inCollection:(UIView&lt;I3Collection&gt; *)collection</pre></div>

<p>Every data update method has an associated assertion method; the gesture coordinator will only respond to an event if and only if, both the update methods and its associated assertion have been implemented. For example, if you implement:</p>

<div class="highlight highlight-Objective-C"><pre>-(<span class="pl-st">void</span>) rearrangeItemAt:(<span class="pl-s3">NSIndexPath</span> *)from withItemAt:(<span class="pl-s3">NSIndexPath</span> *)to inCollection:(UIView&lt;I3Collection&gt; *)collection</pre></div>

<p>but not:</p>

<div class="highlight highlight-Objective-C"><pre>-(<span class="pl-st">BOOL</span>) canItemFrom:(<span class="pl-s3">NSIndexPath</span> *)from beRearrangedWithItemAt:(<span class="pl-s3">NSIndexPath</span> *)to inCollection:(UIView&lt;I3Collection&gt; *)collection</pre></div>

<p>then the coordinator will assume that we don't want to rearrange anything.</p>

<h3>
<a id="render-delegate" class="anchor" href="#render-delegate" aria-hidden="true"><span class="octicon octicon-link"></span></a>Render Delegate</h3>

<p>Classes that conform to <code>I3DragRenderDelegate</code> are responsible for rendering drag/drop events on-screen.</p>

<p>The framework provides a basic implementation of the <code>I3DragRenderDelegate</code> in the form of the <code>I3BasicRenderDelegate</code>. There's nothing stopping you extending <code>I3BasicRenderDelegate</code> or even implementing your own from scratch by conforming to <code>I3DragRenderDelegate</code>.</p>

<p>The gesture coordinator will call the render delegate whenever it wants to render a particularly event. Note that a render delegate may assume that its methods will be called by the coordinator in a specific order and it may manage the lifecycle of its state based on that order. As a general rule, its best never to call the the <code>I3DragRenderDelegate</code> methods directly - just let the coordinator call them.</p>

<p>Its also worth noting that the gesture coordinator retains a <em>strong</em> reference to the render delegate to avoid you having to retain it yourself unnecessarily. For this reason, take care when implementing a render delegate that 'knows' about its gesture coordinator and remain mindful of potential retain cycles.</p>

<h3>
<a id="setting-up-a-drag-and-drop-environment" class="anchor" href="#setting-up-a-drag-and-drop-environment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Setting Up a Drag-and-Drop Environment</h3>

<p>So to top it off, here is a snippet demonstrating setting up a drag/drop environment using all of the core components:</p>

<div class="highlight highlight-Objective-C"><pre>
#<span class="pl-k">import</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>BetweenKit/I3GestureCoordinator.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">import</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>BetweenKit/I3BasicRenderDelegate.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">import</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>BetweenKit/I3DragDataSource.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">import</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>BetweenKit/UITableView+I3Collection.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">import</span> <span class="pl-s1"><span class="pl-pds">&lt;</span>BetweenKit/UICollectionView+I3Collection.h<span class="pl-pds">&gt;</span></span>

...

UIView *superview = ...
<span class="pl-st">id</span>&lt;I3DragDataSource&gt; dataSource = ...

I3DragArena *arena = [[I3DragArena <span class="pl-s3">alloc</span>] <span class="pl-s3">initWithSuperview:</span>superview <span class="pl-s3">containingCollections:</span>@[collection1, collection2, ...]];
I3GestureCoordinator *coordinator = [[I3GestureCoordinator <span class="pl-s3">alloc</span>] <span class="pl-s3">initWithDragArena:</span>arena <span class="pl-s3">withGestureRecognizer:</span>[[UILongPressGestureRecognizer <span class="pl-s3">alloc</span>] <span class="pl-s3">init</span>]];

coordinator.renderDelegate = [[I3BasicRenderDelegate <span class="pl-s3">alloc</span>] <span class="pl-s3">init</span>];
coordinator.dragDataSource = dataSource;

</pre></div>

<p>As you can see, the gesture coordinator is dependent mainly on abstractions (the <code>I3DragDataSource</code> protocol, the <code>I3DragRenderDelegate</code> protocol, the abstract <code>UIGestureRecongizer</code> class, etc.), which leaves room for a great deal of extension.</p>

<p>The <code>I3GestureCoordinator</code> provides a couple of helpful factory methods in the form of class methods:</p>

<div class="highlight highlight-Objective-C"><pre>
+(<span class="pl-st">instancetype</span>) basicGestureCoordinatorFromViewController:(UIViewController *)viewController withCollections:(<span class="pl-s3">NSArray</span> *)collections withRecognizer:(UIGestureRecognizer *)recognizer;

+(<span class="pl-st">instancetype</span>) basicGestureCoordinatorFromViewController:(UIViewController *)viewController withCollections:(<span class="pl-s3">NSArray</span> *)collections;
</pre></div>

<p>You can use these methods in place of all the setup boilerplate where possible, for example</p>

<div class="highlight highlight-Objective-C"><pre>
MyViewController *viewController = ...
I3DragCoordinator *coordinator = [I3GestureCoordinator <span class="pl-s3">basicGestureCoordinatorFromViewController:</span>viewController <span class="pl-s3">withCollections:</span>@[collection1, collection2, ...]];
</pre></div>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/ice3-software">ice3-software</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>